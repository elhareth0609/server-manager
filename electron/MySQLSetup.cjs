// MySQLSetup.cjs
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process'); // Removed 'exec' as execAsync is not used in the core setup part requested
const { promisify } = require('util');

// execAsync might still be needed for testConnection and stopServer, but not for setup/init
// const execAsync = promisify(require('child_process').exec); 

class MySQLSetup {
    constructor(config = {}) {
        this.config = {
            baseDir: config.baseDir || 'C:/server-manager/bin/mysql/mysql-8.0.x-winx64', // Should be dynamically set
            dataDir: config.dataDir || 'C:/server-manager/data/mysql',
            configDir: config.configDir || 'C:/server-manager/config/mysql', 
            port: config.port || 3306,
            bindAddress: config.bindAddress || '127.0.0.1',
            socket: config.socket || (config.baseDir ? path.join(config.baseDir, 'mysql.sock').replace(/\\/g, '/') : 'mysql.sock'),
            ...config
        };
        
        this.binDir = path.join(this.config.baseDir, 'bin');
        this.configFile = path.join(this.config.baseDir, 'my.ini'); 
    }

    normalizePathForIni(p) {
        if (!p) return '';
        return p.replace(/\\/g, '/');
    }

    generateConfigContent() {
        const norm = this.normalizePathForIni.bind(this);
        const pidFilePath = norm(path.join(this.config.dataDir, 'mysql.pid'));
        const socketPath = norm(this.config.socket);

        return `\
# MySQL Configuration File (my.ini)
# Generated by Server Manager
[mysqld]
basedir=${norm(this.config.baseDir)}
datadir=${norm(this.config.dataDir)}
port=${this.config.port}
bind-address=${this.config.bindAddress}
socket=${socketPath}
pid-file=${pidFilePath}
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
default_authentication_plugin=mysql_native_password

# Optional: Add other settings like innodb_buffer_pool_size if needed

[client]
port=${this.config.port}
socket=${socketPath}
`;
    }

    async createDirectories() {
        const directories = [
            this.config.dataDir, // Essential for MySQL data
            this.config.configDir // For other general configs, if any (my.ini is in baseDir)
        ];

        const results = [];
        
        for (const dir of directories) {
            try {
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                    results.push({ dir, status: 'created' });
                    console.log(`Created directory: ${dir}`);
                } else {
                    results.push({ dir, status: 'exists' });
                }
            } catch (error) {
                results.push({ dir, status: 'error', error: error.message });
                console.error(`Failed to create directory ${dir}: ${error.message}`);
            }
        }
        if (results.some(r => r.status === 'error' && [this.config.dataDir].includes(r.dir))) {
            throw new Error('Failed to create one or more critical MySQL directories.');
        }
        return results;
    }

    async verifyInstallation() {
        const mysqldPath = path.join(this.binDir, 'mysqld.exe');
        const mysqlPath = path.join(this.binDir, 'mysql.exe');

        const checks = [
            { name: 'mysqld.exe', path: mysqldPath },
            { name: 'mysql.exe', path: mysqlPath }
        ];

        const results = [];
        let allExist = true;

        for (const check of checks) {
            const exists = fs.existsSync(check.path);
            results.push({
                name: check.name,
                path: check.path,
                exists
            });
            if (!exists) {
                allExist = false;
                console.error(`MySQL binary not found: ${check.path}`);
            }
        }
        
        if (!allExist) {
            throw new Error(`MySQL binary verification failed. Check paths in ${this.binDir}`);
        }
        console.log('MySQL binaries verified successfully.');
        return results;
    }

    async createConfigFile(overwrite = false) {
        if (fs.existsSync(this.configFile) && !overwrite) {
            console.log(`Config file ${this.configFile} already exists. Not overwriting.`);
            return { status: 'exists', path: this.configFile };
        }

        try {
            const configContent = this.generateConfigContent();
            fs.writeFileSync(this.configFile, configContent, 'utf8');
            console.log(`Successfully created MySQL config file: ${this.configFile}`);
            return { status: 'created', path: this.configFile };
        } catch (error) {
            console.error(`Failed to create config file ${this.configFile}: ${error.message}`);
            throw new Error(`Failed to create config file: ${error.message}`);
        }
    }

    isInitialized() {
        const mysqlSystemDbDir = path.join(this.config.dataDir, 'mysql');
        const autoCnfFile = path.join(this.config.dataDir, 'auto.cnf'); // Correctly defined
        return fs.existsSync(mysqlSystemDbDir) && fs.existsSync(autoCnfFile);
    }

    async initializeDatabase(forceReinit = false) {
        if (this.isInitialized() && !forceReinit) {
            console.log('Database already initialized. Skipping re-initialization.');
            return { 
                status: 'already_initialized', 
                message: 'Database already initialized' 
            };
        }

        if (forceReinit && fs.existsSync(this.config.dataDir)) {
            console.log(`Force re-initialization: Removing existing data directory ${this.config.dataDir}...`);
            try {
                fs.rmSync(this.config.dataDir, { recursive: true, force: true });
                fs.mkdirSync(this.config.dataDir, { recursive: true });
                console.log('Data directory cleared and recreated.');
            } catch (error) {
                console.error(`Failed to clear data directory ${this.config.dataDir}: ${error.message}`);
                throw new Error(`Failed to clear data directory: ${error.message}`);
            }
        } else if (!fs.existsSync(this.config.dataDir)) {
            fs.mkdirSync(this.config.dataDir, { recursive: true });
            console.log(`Created data directory: ${this.config.dataDir}`);
        }


        return new Promise((resolve, reject) => {
            const mysqldPath = path.join(this.binDir, 'mysqld.exe');
            const args = [
                `--defaults-file=${this.configFile}`,
                '--initialize-insecure', // No temporary password for root@localhost
                '--console'
            ];
            
            console.log(`Initializing database with command: "${mysqldPath}" ${args.join(' ')}`);
            console.log(`Using CWD: ${this.binDir}`);

            const child = spawn(`"${mysqldPath}"`, args, {
                cwd: this.binDir,
                shell: true,
                stdio: ['ignore', 'pipe', 'pipe']
            });

            let output = '';
            let errorOutput = '';

            child.stdout.on('data', (data) => {
                const msg = data.toString();
                console.log('INIT STDOUT:', msg);
                output += msg;
            });

            child.stderr.on('data', (data) => {
                const msg = data.toString();
                console.error('INIT STDERR:', msg);
                errorOutput += msg;
            });

            child.on('close', (code) => {
                const fullLog = output + errorOutput;
                if (code === 0) {
                    console.log("MySQL Initialized successfully (with --initialize-insecure).");
                    resolve({
                        status: 'initialized',
                        tempPassword: null, // No password with --initialize-insecure
                        output: fullLog
                    });
                } else {
                    console.error(`Database initialization failed with code ${code}.`);
                    reject(new Error(`Database initialization failed with code ${code}:\n${fullLog}`));
                }
            });

            child.on('error', (error) => {
                console.error(`Failed to start MySQL initialization process: ${error.message}`);
                reject(new Error(`Failed to start initialization process: ${error.message}`));
            });
        });
    }

    // ... (startServer, testConnection, stopServer methods remain as they are)
    // For brevity, I'm omitting them here but they are part of the class.
    // Ensure they also use quoted paths for executables if calling via shell:true or directly.

    /**
     * Start MySQL server
     */
    async startServer() {
        return new Promise((resolve, reject) => {
            const mysqldPath = path.join(this.binDir, 'mysqld.exe');
            const args = [
                `--defaults-file=${this.configFile}`,
                '--console'
            ];

            console.log(`Starting MySQL server: "${mysqldPath}" ${args.join(' ')}`);

            const child = spawn(`"${mysqldPath}"`, args, {
                cwd: this.binDir,
                shell: true,
                stdio: ['ignore', 'pipe', 'pipe'],
                detached: true // Allows parent to exit while server runs
            });

            child.unref(); // Important for detached process

            let output = '';
            let errorOutput = '';
            let isReady = false;

            const timeoutDuration = 60000; // 60 seconds timeout
            const readyTimeout = setTimeout(() => {
                if (!isReady) {
                    child.kill(); // Try to kill the process
                    console.error('MySQL server startup timed out.');
                    reject(new Error(`Server startup timeout (${timeoutDuration/1000}s)`));
                }
            }, timeoutDuration);

            const readyListener = (data) => {
                const msg = data.toString();
                output += msg;
                // Look for common ready signals
                if (msg.includes('ready for connections') || msg.includes(`port: ${this.config.port}`)) {
                    if (!isReady) {
                        isReady = true;
                        clearTimeout(readyTimeout);
                        console.log(`MySQL server started successfully. PID: ${child.pid}`);
                        resolve({
                            status: 'started',
                            pid: child.pid,
                            output: output
                        });
                    }
                }
            };
            
            child.stdout.on('data', readyListener);
            child.stderr.on('data', (data) => { // Also listen to stderr as some info might go there
                errorOutput += data.toString();
                readyListener(data); // Check stderr for ready messages too
                console.error("MySQL STDERR:", data.toString());
            });

            child.on('close', (code) => {
                clearTimeout(readyTimeout);
                if (!isReady) { // If closed before ready
                    console.error(`MySQL server exited prematurely with code ${code}.`);
                    reject(new Error(`Server exited with code ${code} before becoming ready:\nstdout: ${output}\nstderr: ${errorOutput}`));
                }
            });

            child.on('error', (error) => {
                clearTimeout(readyTimeout);
                console.error(`Failed to start MySQL server process: ${error.message}`);
                reject(new Error(`Failed to start server: ${error.message}`));
            });
        });
    }

    /**
     * Test MySQL connection
     */
    async testConnection(username = 'root', password = '') {
        const mysqladminPath = path.join(this.binDir, 'mysqladmin.exe');
        const args = [
            `--port=${this.config.port}`,
            `--host=${this.config.bindAddress}`,
            `--user=${username}`
        ];

        if (password) {
            args.push(`--password=${password}`); // Note: exposing password on command line is a security risk
        }                                         // Consider using environment variables or option files for mysqladmin

        args.push('ping');
        const command = `"${mysqladminPath}" ${args.join(' ')}`;
        console.log(`Testing connection: ${command}`);

        try {
            // Set a timeout for execAsync as well
            const { stdout, stderr } = await execAsync(command, { timeout: 10000 }); // 10s timeout
            if (stderr && !stdout.includes("mysqld is alive")) { // Sometimes ping success also has stderr info
                console.warn("Connection test stderr:", stderr);
            }
            if (stdout.includes("mysqld is alive")) {
                 console.log("Connection test successful:", stdout.trim());
                 return { status: 'connected', output: stdout, error: stderr };
            }
            // If "mysqld is alive" is not in stdout, but no error thrown, it might be a soft fail.
            console.error("Connection test failed. stdout:", stdout, "stderr:", stderr);
            return { status: 'failed', error: `Ping command did not confirm alive status. Output: ${stdout}\nError: ${stderr}`};
        } catch (error) {
            console.error(`Connection test command failed: ${error.message}`);
            return { status: 'failed', error: error.message };
        }
    }

    /**
     * Stop MySQL server
     */
    async stopServer(username = 'root', password = '') {
        const mysqladminPath = path.join(this.binDir, 'mysqladmin.exe');
        const args = [
            `--port=${this.config.port}`,
            `--host=${this.config.bindAddress}`,
            `--user=${username}`
        ];

        if (password) {
            args.push(`--password=${password}`);
        }

        args.push('shutdown');
        const command = `"${mysqladminPath}" ${args.join(' ')}`;
        console.log(`Stopping server: ${command}`);

        try {
            const { stdout, stderr } = await execAsync(command, { timeout: 20000 }); // 20s timeout
            console.log("Server stop command stdout:", stdout);
            if (stderr) {
                 console.warn("Server stop command stderr:", stderr);
            }
            return { status: 'stopped', output: stdout, error: stderr };
        } catch (error) {
            // Shutdown can return non-zero exit code even on success if server was already stopping
            if (error.message.includes('Can\'t connect to MySQL server') || error.code === null ) {
                 console.warn(`Server stop command indicated server might already be down or failed to connect: ${error.message}`);
                 // Check if PID file is gone or process is gone as secondary check
                 return { status: 'likely_stopped_or_unreachable', error: error.message };
            }
            console.error(`Server stop command failed: ${error.message}`);
            return { status: 'failed_to_stop', error: error.message };
        }
    }
}

module.exports = MySQLSetup;



// const fs = require('fs');
// const path = require('path');
// const { spawn, exec } = require('child_process');
// const { promisify } = require('util');

// const execAsync = promisify(exec);

// class MySQLSetup {
//     constructor(config = {}) {
//         this.config = {
//             baseDir: config.baseDir || 'C:/server-manager/bin/mysql/mysql-8.0.42-winx64',
//             dataDir: config.dataDir || 'C:/server-manager/bin/mysql/mysql-8.0.42-winx64/data',
//             logsDir: config.logsDir || 'C:/server-manager/logs/mysql',
//             tmpDir: config.tmpDir || 'C:/server-manager/tmp/mysql',
//             configDir: config.configDir || 'C:/server-manager/config/mysql',
//             port: config.port || 3306,
//             bindAddress: config.bindAddress || '127.0.0.1',
//             ...config
//         };
        
//         this.binDir = path.join(this.config.baseDir, 'bin');
//         this.configFile = path.join(this.config.baseDir, 'my.ini');
//     }

//     /**
//      * Generate MySQL configuration file content
//      */
//     generateConfigContent() {
//         return `# MySQL Configuration File (my.ini)
// # Generated by Server Manager

// [client]
// port=${this.config.port}
// socket="${this.config.baseDir}/mysql.sock"
// default-character-set=utf8mb4

// [mysql]
// default-character-set=utf8mb4
// auto-rehash
// show-warnings

// [mysqld]
// # === BASIC CONFIGURATION ===
// basedir="${this.config.baseDir}"
// datadir="${this.config.dataDir}"
// port=${this.config.port}
// socket="${this.config.baseDir}/mysql.sock"
// pid-file="${this.config.dataDir}/mysql.pid"

// # === STORAGE ENGINE CONFIGURATION ===
// default_storage_engine=INNODB
// innodb_buffer_pool_size=256M
// innodb_log_file_size=64M
// innodb_log_buffer_size=16M
// innodb_flush_log_at_trx_commit=2
// innodb_file_per_table=1
// innodb_open_files=400

// # === SQL MODE CONFIGURATION ===
// sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ZERO_DATE,NO_ZERO_IN_DATE

// # === NETWORKING CONFIGURATION ===
// bind-address=${this.config.bindAddress}
// skip-name-resolve=1
// max_connections=200
// connect_timeout=10
// wait_timeout=28800
// interactive_timeout=28800

// # === LOGGING CONFIGURATION ===
// log_error="${this.config.logsDir}/mysql_error.log"
// general_log=0
// general_log_file="${this.config.logsDir}/mysql_general.log"
// slow_query_log=1
// slow_query_log_file="${this.config.logsDir}/mysql_slow.log"
// long_query_time=2
// log_bin="${this.config.logsDir}/mysql_bin"
// binlog_format=ROW
// expire_logs_days=7
// max_binlog_size=100M

// # === CHARACTER SET CONFIGURATION ===
// character-set-server=utf8mb4
// collation-server=utf8mb4_unicode_ci
// init_connect='SET NAMES utf8mb4'

// # === SECURITY CONFIGURATION ===
// local-infile=0
// secure_file_priv="${this.config.tmpDir}"

// # === PERFORMANCE CONFIGURATION ===
// query_cache_type=0
// query_cache_size=0
// table_open_cache=400
// table_definition_cache=400
// thread_cache_size=16
// sort_buffer_size=2M
// join_buffer_size=2M
// read_buffer_size=1M
// read_rnd_buffer_size=2M
// key_buffer_size=32M
// bulk_insert_buffer_size=8M
// myisam_sort_buffer_size=64M
// myisam_max_sort_file_size=1G
// myisam_repair_threads=1
// tmp_table_size=64M
// max_heap_table_size=64M
// tmpdir="${this.config.tmpDir}"

// [mysqldump]
// quick
// quote-names
// max_allowed_packet=64M
// default-character-set=utf8mb4

// [mysql.server]
// user=mysql
// basedir="${this.config.baseDir}"

// [mysqld_safe]
// log-error="${this.config.logsDir}/mysql_error.log"
// pid-file="${this.config.dataDir}/mysql.pid"
// `;
//     }

//     /**
//      * Create required directories
//      */
//     async createDirectories() {
//         const directories = [
//             this.config.dataDir,
//             this.config.logsDir,
//             this.config.tmpDir,
//             this.config.configDir
//         ];

//         const results = [];
        
//         for (const dir of directories) {
//             try {
//                 if (!fs.existsSync(dir)) {
//                     fs.mkdirSync(dir, { recursive: true });
//                     results.push({ dir, status: 'created' });
//                 } else {
//                     results.push({ dir, status: 'exists' });
//                 }
//             } catch (error) {
//                 results.push({ dir, status: 'error', error: error.message });
//                 throw new Error(`Failed to create directory ${dir}: ${error.message}`);
//             }
//         }

//         return results;
//     }

//     /**
//      * Verify MySQL installation
//      */
//     async verifyInstallation() {
//         const mysqldPath = path.join(this.binDir, 'mysqld.exe');
//         const mysqlPath = path.join(this.binDir, 'mysql.exe');

//         const checks = [
//             { name: 'mysqld.exe', path: mysqldPath },
//             { name: 'mysql.exe', path: mysqlPath }
//         ];

//         const results = [];

//         for (const check of checks) {
//             const exists = fs.existsSync(check.path);
//             results.push({
//                 name: check.name,
//                 path: check.path,
//                 exists
//             });

//             if (!exists) {
//                 throw new Error(`MySQL binary not found: ${check.path}`);
//             }
//         }

//         return results;
//     }

//     /**
//      * Create configuration file
//      */
//     async createConfigFile(overwrite = false) {
//         if (fs.existsSync(this.configFile) && !overwrite) {
//             return { status: 'exists', path: this.configFile };
//         }

//         try {
//             const configContent = this.generateConfigContent();
//             fs.writeFileSync(this.configFile, configContent, 'utf8');
//             return { status: 'created', path: this.configFile };
//         } catch (error) {
//             throw new Error(`Failed to create config file: ${error.message}`);
//         }
//     }

//     /**
//      * Check if database is already initialized
//      */
//     isInitialized() {
//         const mysqlSystemDir = path.join(this.config.dataDir, 'mysql');
//         return fs.existsSync(mysqlSystemDir);
//     }

//     /**
//      * Initialize MySQL database
//      */
//     async initializeDatabase(forceReinit = false) {
//         if (this.isInitialized() && !forceReinit) {
//             return { status: 'already_initialized', message: 'Database already initialized' };
//         }

//         if (forceReinit && this.isInitialized()) {
//             // Remove existing data directory
//             try {
//                 fs.rmSync(this.config.dataDir, { recursive: true, force: true });
//                 fs.mkdirSync(this.config.dataDir, { recursive: true });
//             } catch (error) {
//                 throw new Error(`Failed to clear data directory: ${error.message}`);
//             }
//         }

//         return new Promise((resolve, reject) => {
//             const mysqldPath = path.join(this.binDir, 'mysqld.exe');
//             const args = [
//                 '--defaults-file=' + this.configFile,
//                 '--initialize',
//                 '--console'
//             ];

//             console.log(`Initializing database: ${mysqldPath} ${args.join(' ')}`);

//             const child = spawn(mysqldPath, args, {
//                 cwd: this.binDir,
//                 stdio: ['ignore', 'pipe', 'pipe']
//             });

//             let output = '';
//             let errorOutput = '';

//             child.stdout.on('data', (data) => {
//                 output += data.toString();
//             });

//             child.stderr.on('data', (data) => {
//                 errorOutput += data.toString();
//             });

//             child.on('close', (code) => {
//                 if (code === 0) {
//                     // Extract temporary password from output
//                     const tempPasswordMatch = (output + errorOutput).match(/temporary password is generated for root@localhost: (.+)/);
//                     const tempPassword = tempPasswordMatch ? tempPasswordMatch[1].trim() : null;

//                     resolve({
//                         status: 'initialized',
//                         tempPassword,
//                         output: output + errorOutput
//                     });
//                 } else {
//                     reject(new Error(`Database initialization failed with code ${code}:\n${errorOutput}\n${output}`));
//                 }
//             });

//             child.on('error', (error) => {
//                 reject(new Error(`Failed to start initialization process: ${error.message}`));
//             });
//         });
//     }

//     /**
//      * Start MySQL server
//      */
//     async startServer() {
//         return new Promise((resolve, reject) => {
//             const mysqldPath = path.join(this.binDir, 'mysqld.exe');
//             const args = [
//                 '--defaults-file=' + this.configFile,
//                 '--console'
//             ];

//             const child = spawn(mysqldPath, args, {
//                 cwd: this.binDir,
//                 stdio: ['ignore', 'pipe', 'pipe'],
//                 detached: true
//             });

//             let output = '';
//             let isReady = false;

//             const timeout = setTimeout(() => {
//                 if (!isReady) {
//                     child.kill();
//                     reject(new Error('Server startup timeout'));
//                 }
//             }, 30000); // 30 second timeout

//             child.stdout.on('data', (data) => {
//                 output += data.toString();
//                 if (output.includes('ready for connections') || output.includes('port: ' + this.config.port)) {
//                     isReady = true;
//                     clearTimeout(timeout);
//                     resolve({
//                         status: 'started',
//                         pid: child.pid,
//                         output
//                     });
//                 }
//             });

//             child.stderr.on('data', (data) => {
//                 output += data.toString();
//                 if (output.includes('ready for connections') || output.includes('port: ' + this.config.port)) {
//                     isReady = true;
//                     clearTimeout(timeout);
//                     resolve({
//                         status: 'started',
//                         pid: child.pid,
//                         output
//                     });
//                 }
//             });

//             child.on('close', (code) => {
//                 clearTimeout(timeout);
//                 if (!isReady) {
//                     reject(new Error(`Server exited with code ${code}: ${output}`));
//                 }
//             });

//             child.on('error', (error) => {
//                 clearTimeout(timeout);
//                 reject(new Error(`Failed to start server: ${error.message}`));
//             });
//         });
//     }

//     /**
//      * Test MySQL connection
//      */
//     async testConnection(username = 'root', password = '') {
//         const mysqladminPath = path.join(this.binDir, 'mysqladmin.exe');
//         const args = [
//             '--port=' + this.config.port,
//             '--host=' + this.config.bindAddress,
//             '--user=' + username
//         ];

//         if (password) {
//             args.push('--password=' + password);
//         }

//         args.push('ping');

//         try {
//             const { stdout, stderr } = await execAsync(`"${mysqladminPath}" ${args.join(' ')}`);
//             return {
//                 status: 'connected',
//                 output: stdout,
//                 error: stderr
//             };
//         } catch (error) {
//             return {
//                 status: 'failed',
//                 error: error.message
//             };
//         }
//     }

//     /**
//      * Stop MySQL server
//      */
//     async stopServer(username = 'root', password = '') {
//         const mysqladminPath = path.join(this.binDir, 'mysqladmin.exe');
//         const args = [
//             '--port=' + this.config.port,
//             '--host=' + this.config.bindAddress,
//             '--user=' + username
//         ];

//         if (password) {
//             args.push('--password=' + password);
//         }

//         args.push('shutdown');

//         try {
//             const { stdout, stderr } = await execAsync(`"${mysqladminPath}" ${args.join(' ')}`);
//             return {
//                 status: 'stoppe